# Redux

애플리케이션 **상태(state)**를 용이하게 관리하기 위한 **프레임워크(오픈 소스 JS 라이브러리)**

+ **React의 라이브러리가 아니다! Angular, Vue, Vanilla 어디서든 쓸 수 있다.**

### Redux의 데이터 흐름

React Native 세계관

1. 유저의 Input: Event 발생

---

Redux 세계관

2. Action Creator: 함수 A, 함수 B, 함수 C
3. dispatch(action): Redux Store에게 객체 형태인 action을 전달한다.
4. Store: state와 state의 변화를 일으키는 함수들, Reducer들이 존재하고 이들로 인하여 state가 변한다.
5. connect: 새롭게 업데이트된 state들을 React Native쪽으로 보내기 위해 연결하는 역할을 한다.
   + `.mapStateToProps`
   + `.mapDispatchToProps`

---

React Native의 세계관

6. Output: 새로운 화면

이러한 과정으로 React Native의 컴포넌트들은 Redux의 세계에 절대 관여가 불가능하다. 오로지 Redux에서만이 connect를 통해 컴포넌트들에게 일방통행을 시전한다.

<br>

### action과 action creator

#### action

우리의 앱은 정적이지 않다. 앱에서 일어나는 이벤트에 따라 화면에 렌더링 되는 양상이 달라질 것이다.

데이터의 변경으로 인해 이렇게 화면이 달라지게 되는데, **상태(state)를 변경하기 위해 발생**하는 것을 **액션(action)**이라고 한다.

**객체 형식**으로 표현된다.

+ 반드시 **type**을 갖고 있으며, 그 외 text나 payload와 같은 것들을 전달해줄 수 있다.

```
{
	type: "EXAMPLE_TYPE"
	text: "텍스트 문구"
	payload: amount
}
```

#### action creator

action을 생성하는 함수 = action을 반환하는 함수

다음과 같은 형태를 갖는다.

```react
const withdrawMoney = (param) => {
  // code
  
  // 이부분부터 action
  return {
    type: WITHDRAW_MONEY,
    payload: amount
  }
}
```

<br>

### dispatch

Store의 내장 함수 중 하나

Reducer에게 어떤 action이 발생했는지 알리는 함수

+ state의 값을 바꾸는 것은 결국 Reducer다.

`distpath(action)` 또는 `dispatch(actionCreator(param))`과 같은 형태로 사용한다.

이렇게 호출하면 store에서 reducer를 실행하고 state의 업데이트가 이루어지는 것이다.

<br>

### store

하나의 App에 단 하나의 store만 존재

state, reducer 및 기타 내장 함수 존재

### state

데이터 및 UI 상태 등 어플리케이션을 유지하기 위한 정보

state의 변경 <=> View의 변경

<br>

### reducer

**state에 변화를 일으키는 함수!** (함수다 함수!)

Input: state, action

Output: state`(변경된 값)

다음과 같이 정의된다.

+ type에 따라 분기되는 로직을 처리하므로 action에 type이 꼭 들어가는 것이다.

```react
export sampleReducer (state=initialState, action) {
  switch (action.type) {
    case WITHDRAW_MONEY:
      return {
        ...state,
        account: payload
      }
    default:
      return state
  }
}
```

<br>

### connect

RN 세계관과 Redux 세계관의 연결 함수

store 내 state의 업데이트 된 값을 컴포넌트가 그대로 받을 수 있는가? -> 아니다. 왜?

+ 컴포넌트가 store로부터 어떠한 데이터를 받는 경우 그 형태는 props가 되어야 한다.
+ 이 props는 **불변**, 즉 변동되지 않는 데이터다.
+ **따라서 state가 변경될 때마다 아예 새로운 컴포넌트를 생성한다고 생각해야 한다.**

store가 가진 state를 어떻게 props에 엮을지 -> `mapStateProps`

reducer에 action을 알리는 함수 dispatch를 어떻게 props에 엮을지 -> `mapDispatchToProps`

이 두 가지를 이용해 다음과 같이 connect 함수를 꾸미게 된다.

`connect(mapStateProps, mapDispatchToProps)(component)`

<br>

### Redux의 3원칙

#### Single Source of Truth (신뢰 가능한 유일한 정보원)

어플리케이션의 모든 state는 단일 store에서 관리

#### State in Read-Only (state는 읽기 전용)

state의 변경은 반드시 action을 통해서

#### Changes are Made with Pure Functions (변경은 순수함수를 통해서만)

reducer는 순수함수로 정의

+ 인수 변경 x
+ API 호출 x
+ 네트워크 요청 x
+ 순수함수가 아닌 함수 Date.now(), Math.random() 호출 x

<br>

<br>

## 실제 Redux 셋업

### 우선 Vanilla 예시

```js
import { createStore } from "redux";

const add = document.getElementById("add");
const minus = document.getElementById("minus");
const number = document.querySelector("span");

number.innerText = 0;

const ADD = "ADD";
const MINUS = "MINUS";

// const countModifier = (count = 0) => {
//   return count;
const countModifier = (count = 0, action) => {
  switch (action.type) {
    case ADD:
      return count + 1;
    case MINUS:
      return count - 1;
    default:
      return count;
};

const countStore = createStore(countModifier);

const onChange = () => {
  number.innerText = countStore.getState();
};

// store 안에 있는 state에 변화가 있으면 함수를 실행해주는 구독 기능
countStore.subscribe(onChange);

// { type: ADD }가 action
const handleAdd = () => {
  countStore.dispatch({ type: ADD });
};

const handleMinus = () => {
  countStore.dispatch({ type: MINUS });
};

add.addEventListener("click", handleAdd);
minus.addEventListener("click", handleMinus);
```

<br>

### RN

새로운 프로젝트 생성

`npm install redux react-redux redux-promise @reduxjs/toolkit`

https://github.com/ClintJang/sample-react-native-redux-architecture-patterns 구성 참고

store라는 폴더 안에 store.js, reducers.js를 만들어보자.

```react
// App.js

import { Provider } from 'react-redux';
import Store from './src/store/store';
...

const store = Store()

export default function App() {
  return (
    <Provider store={store}>
      <NavigationContainer>
        <Root />
        {/* <Main/> */}
      </NavigationContainer>
    </Provider>
  );
}



// store.js
import { createStore, applyMiddleware, compose } from 'redux';
import promiseMiddleware from 'redux-promise';
import reducers from './reducers';

const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose

export default function Store() {
  const store = createStore(reducers, composeEnhancers(
    applyMiddleware(promiseMiddleware)
  ));
  return store;
}



// reducers.js
import { combineReducers } from 'redux';
import { createAction, createReducer } from "@reduxjs/toolkit";

// 기본 State 정리
const defaultState = {
  userId: 0,
}

// Actions 정의
const login = createAction("LOGIN");
const logout = createAction("LOGOUT");


// Reducer 정의
const UserReducer = createReducer(defaultState, {
  [login]: (state, action) => {
    // 로그인 시 state 변경 로직
    // state.push({ text: action.payload, id: Date.now() });
  },
  // [logout]: (state, action) => 
    // 로그아웃 시 state 변경 로직
    // state.filter(toDo => toDo.id !== action.payload)
});


export default combineReducers({
  user: UserReducer,
});
```

사용하는 예시(위랑 전혀 다른 프로젝트임)

```react
import {connect} from 'react-redux';
import ActionCreator from '../actions';


class Calculator extends Component {
  ...
  this.props.result
  this.props.updateSecond(numberAsInt); 
}

  
function mapStateToProps(state) {
    return {
        result: state.calculator.result,
        first: state.calculator.sumInfo.first,
        second: state.calculator.sumInfo.second
    };
}

function mapDispatchToProps(dispatch) {
    return {
        updateFirst:(num) => {
            dispatch(ActionCreator.updateSumValueFirst(num));

        },
        updateSecond:(num) => {
            dispatch(ActionCreator.updateSumValueSecond(num));
        }
    };
}

...

export default connect(mapStateToProps, mapDispatchToProps)(Calculator);
```

추가로, 노마드코더의 '초보자를 위한 리덕스 101' 3, 4번째 파트 강의를 보면 매우 쉽게 이해 가능하다.

내가 헷갈렸던 부분

+ Reducer를 위 코드처럼 UserReducer 등으로 분리해서 개발하는 경우가 있는데, 마지막에 combineReducers로 모아준다. 나는 이때 어떠한 의미가 있는줄 알았다.
+ 하지만, 아니다. **Reducer는 그냥 다 모아서 하나의 Reducer로 생각하자.** 우리는 컴포넌트에서 **Action**만 dispatch로 부를 것이다. **이 Action으로 어느 Reducer에서 처리할 것인지는 알아서 찾아간다.**
+ 즉, **컴포넌트에서 Reducer를 사용하거나 분간해야 하는 일은 절대 없다.**

<br>

### Redux Toolkit

위의 예시 코드에서도 사용한 것

action과 actionCreator를 하나하나 만들지 않고, 굉장히 편하게 action들을 만들 수 있다.

또한, reducer도 기능별로 나누어 관리할 수 있도록 쉽게 reducer를 만들 수 있게 한다.

`npm install @reduxjs/toolkit`

#### createAction

기존의 actionCreator 생성과 사용은 다음과 같다.

```react
const INCREMENT = 'counter/increment'

function increment(amount) {
  return {
    type: INCREMENT,
    payload: amount
  }
}

const action = increment(3)

export const actionCreators = {
  increment
}
```

하지만 createAction을 사용하여 다음과 같이 간단하게 구현할 수 있다.

```react
import { createAction } from '@reduxjs/toolkit'

const increment = createAction("counter/increment")

export const actionCreators = {
  increment
}
```

이 increment의 type은(action의 type말고) function이 된다.

대신 이 경우, reducer 안에서 우리는 전달받는 인자를 무조건 **payload**라는 이름으로만 사용할 수 있다.

#### createReducer

다음과 같이 쉽게 reducer를 만들 수 있다.

+ 이제 action의 type을 이용해서 분기하는 로직을 안써도 된다. actionCreator 함수 그 자체 이름을 쓰자.
+ **가장 큰 장점**: **state를 mutate하기 쉽게 만들어준다.**
  + 원래 state를 변경하기 위해서는 새로운 state를 만들어 리턴해주는 식이었다.
  + 하지만, **이제는 state자체의 변형이 가능하다. 즉, state.push와 같은!**
  + 대신 **mutate할 경우에는 return을 하면 안된다.**

```react
const reducer = createReducer([], {
  [increment]: (state, action) => {
    state.push({ text: action.payload, id: Date.now() })
  }
})
```

### createSlice

reducer뿐만 아니라 action도 만들어주는 녀석이다.

+ 몇가지 옵션을 받는다.
  + name: reducer 이름
  + initialState: state의 초기값
  + reducers: createReducer 안에 작성했던 부분들
+ 이렇게 하면 자동적으로 actions라는 속성이 생기고 그 값에 action들이 들어있다.

```react
const increment = createSlice({
  name: 'countReducer',
  initialState: [],
  reducers: {
    increment: (state, action) => {
      state.push({ text: action.payload, id: Date.now() })
    }
  }
})

export const { increment } = increment.actions
```

#### combineReducers

여러 나뉜 reducer들을 모아서 export 할 수 있도록 도와준다. name을 지어서 매핑해준다.

**이때, 컴포넌트에서 state를 쓰고자 하면 이 state를 갖고 있는 reducer의 name을 명시해주어야 한다.**

```react
// 기본 state 정의
const defaultState = {
  num: 0
}

// Reducer 정의, defaultState를 첫 번째 인자로 받아 이 state를 갖고 있음
const UserReducer = createReducer(defaultState, {
  [increment]: (state, action) => ({
    ...state,
    num: state.num + action.payload
  })
});

// export하는 곳에서 user라는 이름을 매핑
export default combineReducers({
  user: UserReducer,
})



// 사용하는 곳, state.user를 통해 state에 접근할 수 있다.
function mapStateToProps(state) {
  return {
    deviceWidth: state.user.deviceWidth,
    deviceHeight: state.user.deviceHeight,
    myRadius: state.user.myRadius,
    SERVER_URL: state.user.SERVER_URL,
    userPK: state.user.userPK,
  }
}
```



